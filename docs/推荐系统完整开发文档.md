# 推荐系统完整开发文档

## 📋 项目概述

**项目**: Lemo推荐系统  
**架构**: 前后端分离 + 微服务  
**技术栈**:
- 前端: Vue3 + TypeScript + Arco Design
- 后端网关: Go (Gin框架)
- 推荐服务: Python (gRPC)
- 数据库: MongoDB, MySQL
- 部署: Docker + Kubernetes

---

## 🏗️ 系统架构

```
前端(Vue3) → service_manager(Go网关) → lemo_recommender(Python gRPC服务)
                    ↓                              ↓
              andrew-file(文件服务)            MongoDB
```

### 核心原则

1. **API网关模式**: 前端只与service_manager通信，不直接调用lemo_recommender
2. **自动ID生成**: 所有资源ID(template_id, scenario_id, model_id, item_id, experiment_id)由后端自动生成
3. **租户隔离**: 所有数据按tenant_id隔离
4. **可选筛选**: 列表查询时租户筛选为可选，为空时查询所有

---

## 📁 项目结构

### Go服务 (service_manager)
```
service_manager_server/
├── app/admin/recommender/  # 推荐系统HTTP控制器
│   ├── model.go           # 模型管理
│   ├── template.go        # 模板管理
│   ├── scenario.go        # 场景管理
│   ├── item.go            # 物品管理
│   ├── experiment.go      # AB实验管理
│   └── dataset.go         # 数据集管理
├── rpc/                   # gRPC客户端
│   └── recommender_clients.go
└── route/
    └── router.go          # 路由配置
```

### Python服务 (lemo_recommender)
```
lemo_recommender/
├── app/
│   ├── models/            # Pydantic数据模型
│   │   ├── model.py
│   │   ├── template.py
│   │   ├── scenario.py
│   │   ├── item.py
│   │   └── experiment.py
│   ├── services/          # 业务逻辑层
│   │   ├── model/
│   │   ├── template/
│   │   ├── scenario/
│   │   ├── item/
│   │   └── experiment/
│   └── grpc_server/       # gRPC服务层
│       └── services/
│           ├── model_service.py
│           ├── template_service.py
│           ├── scenario_service.py
│           ├── item_service.py
│           └── experiment_service.py
```

### 前端 (service_manager_web/admin)
```
src/views/recommender/
├── model/                 # 模型管理
│   ├── index.vue
│   ├── Create.vue
│   └── components/
├── template/              # 模板管理
├── scenario/              # 场景管理
├── item/                  # 物品管理
└── experiment/            # AB实验管理
```

---

## 🔑 核心技术要点

### 1. Protobuf数据转换

#### Timestamp转换
```python
# Python: datetime → protobuf Timestamp
from google.protobuf import timestamp_pb2
ts = timestamp_pb2.Timestamp()
ts.FromDatetime(datetime_obj)

# 前端: protobuf → 显示格式
const formatTimestamp = (timestamp: any): string => {
  if (timestamp.seconds !== undefined) {
    const date = new Date(timestamp.seconds * 1000);
    return `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
  }
  return '-';
};
```

#### Enum映射
```python
# Python enum → protobuf enum
status_map = {
    "draft": 1,
    "deployed": 2,
    "archived": 3,
}

# 前端: string value
const statusOptions = [
  { label: '草稿', value: 'draft' },
  { label: '已部署', value: 'deployed' },
];
```

#### Struct转换
```python
# Python dict → protobuf Struct
from google.protobuf import struct_pb2
config_struct = struct_pb2.Struct()
config_struct.update(config_dict)

# protobuf Struct → Python dict
from google.protobuf.json_format import MessageToDict
config_dict = MessageToDict(struct_proto)
```

### 2. Go POST请求参数读取

```go
// ✅ 正确：从POST body读取
body, _ := io.ReadAll(c.Request.Body)
var parameter map[string]interface{}
_ = json.Unmarshal(body, &parameter)

tenantID := ""
if tid, ok := parameter["tenant_id"].(string); ok {
    tenantID = tid
}

// ❌ 错误：用c.Query读取POST参数
tenantID := c.Query("tenant_id")  // 读不到POST body的数据
```

### 3. 前端API调用

```typescript
// defHttp已处理response.data，直接返回数据
const data = await list(params);  // ✅ 正确
const { data } = await list(params);  // ❌ 错误（双重解构）

// 设置row-key
<a-table row-key="model_id" ... />  // ✅ 使用实际字段
<a-table row-key="id" ... />  // ❌ 字段可能不存在

// 分页配置
const basePagination = reactive({ current: 1, pageSize: 20, total: 0 });
```

### 4. MongoDB ObjectID生成

```go
// Go
import "go.mongodb.org/mongo-driver/bson/primitive"
modelID := primitive.NewObjectID().Hex()

// Python
from bson import ObjectId
model_id = ObjectId().hex
```

---

## 📝 开发规范

### 1. ID生成规则
- **所有资源ID由后端自动生成**
- 使用MongoDB ObjectID (24位hex字符串)
- 前端表单不需要输入ID字段

### 2. 租户参数处理
```python
# Python服务支持空租户
filter_query = {}
if tenant_id:  # 有值才加入查询条件
    filter_query["tenant_id"] = tenant_id
```

### 3. 错误处理
```typescript
// 前端空数据处理
try {
  const data = await list(params);
  items.value = data?.items || [];
} catch (error) {
  console.error('查询失败:', error);  // ✅ 只记录日志
  // ❌ 不要: Message.error('查询失败');
}
```

### 4. 时间格式统一
- 数据库: UTC datetime
- Protobuf: Timestamp (seconds + nanos)
- 前端显示: YYYY/MM/DD HH:mm:ss

### 5. 状态映射
```python
# Python Pydantic Enum
class ModelStatus(str, Enum):
    DRAFT = "draft"
    DEPLOYED = "deployed"
    ARCHIVED = "archived"

# Protobuf Enum (从1开始)
enum ModelStatus {
  MODEL_STATUS_UNSPECIFIED = 0;
  MODEL_STATUS_DRAFT = 1;
  MODEL_STATUS_DEPLOYED = 2;
  MODEL_STATUS_ARCHIVED = 3;
}

# 前端显示
const STATUS_MAP = {
  draft: '草稿',
  deployed: '已部署',
  archived: '已归档',
};
```

---

## 🎯 已完成功能模块

### 1. 模型管理 ✅
- ✅ 列表查询（支持租户/类型/状态筛选）
- ✅ 创建模型（自动生成model_id）
- ✅ 编辑模型
- ✅ 删除模型
- ✅ 特征配置（分类结构：user/item/context/interaction）
- ✅ 算法参数配置（根据模型类型动态显示）
- ✅ 训练数据路径配置

**特点**:
- 模型类型: recall/rank/rerank
- 特征分类管理（从字典表动态加载）
- 算法参数带默认值和注释
- 状态颜色标签显示

### 2. 模板管理 ✅
- ✅ 列表查询
- ✅ 创建模板
- ✅ 可视化配置编辑器
- ✅ 模型选择（按类型筛选）
- ✅ 场景类型（从字典表动态加载）

**特点**:
- 不关联租户（跨租户可复用）
- 场景类型配置化
- 可视化配置（Recall/Rank/Rerank）

### 3. 场景管理 ✅
- ✅ 列表查询（支持租户/类型/状态筛选）
- ✅ 创建场景（自动生成scenario_id）
- ✅ 编辑场景
- ✅ 可视化配置编辑器
- ✅ 状态切换

**特点**:
- 与租户绑定
- 基于模板创建
- 支持独立配置

### 4. 物品管理 ✅
- ✅ 列表查询（支持租户/场景/状态筛选）
- ✅ 创建物品（自动生成item_id）
- ✅ 编辑物品
- ✅ 删除物品（软删除）
- ✅ 批量导入

**特点**:
- 按场景组织
- 支持元数据(metadata)
- 支持向量(embedding)

### 5. AB实验管理 ✅
- ✅ 列表查询（支持租户/状态筛选）
- ✅ 创建实验（自动生成experiment_id）
- ✅ 启动/停止实验
- ✅ 删除实验（软删除→archived）
- ✅ 流量分配配置

**特点**:
- 对照组/实验组配置
- 流量分配验证（总和100%）
- 状态流转管理

---

## 🔧 常见问题和解决方案

### 1. 前端列表不显示数据
**原因**: 双重解构或row-key错误  
**解决**:
```typescript
// ✅ 正确
const data = await list(params);
items.value = data?.items || [];

// ✅ 正确row-key
<a-table row-key="model_id" ... />
```

### 2. Go接口读不到POST参数
**原因**: 使用c.Query读取POST body参数  
**解决**:
```go
// ✅ 正确：从body读取
body, _ := io.ReadAll(c.Request.Body)
var parameter map[string]interface{}
_ = json.Unmarshal(body, &parameter)
```

### 3. Python Pydantic验证失败
**原因**: 字典结构与模型不匹配  
**解决**:
```python
# ✅ 使用model_validate
item = Item.model_validate(doc)

# ✅ 使用model_dump转换
result.model_dump()
```

### 4. 时间显示为protobuf格式
**原因**: 未格式化timestamp  
**解决**:
```typescript
// 添加formatTimestamp函数
const formatTimestamp = (timestamp: any): string => {
  if (timestamp.seconds !== undefined) {
    const date = new Date(timestamp.seconds * 1000);
    // 格式化...
  }
  return '-';
};
```

### 5. Enum值不匹配
**原因**: 前端发送字符串，后端期望数字  
**解决**:
```typescript
// ✅ 前端发送字符串
params.model_type = 'recall'  // 不是 1

// Go后端转换
model_type_map := map[string]int{
    "recall": 1,
    "rank": 2,
}
```

---

## 🚀 部署和测试

### Python服务重启
```bash
docker restart lemo_recommender
```

### 前端构建
```bash
cd /Users/edy/Lemo/service_manage/service_manager_web/admin
yarn build
```

### 测试清单
- [ ] 模型管理：列表/创建/编辑/删除
- [ ] 模板管理：列表/创建/编辑
- [ ] 场景管理：列表/创建/编辑/状态切换
- [ ] 物品管理：列表/创建/批量导入
- [ ] AB实验：列表/创建/启动/停止

---

## 📊 数据字典

### 特征字典表
- **表结构**: `common_dictionary_table` (定义表) + `common_dictionary_data` (数据表) 或 动态表
- **特征分类**: 
  - `rec_feature_user` (用户特征)
  - `rec_feature_item` (物品特征)
  - `rec_feature_context` (上下文特征)
  - `rec_feature_interaction` (交互特征)

### 场景类型字典
- **表**: `rec_scenario_type`
- **示例**: vlog, news, ecommerce

---

## 🔐 权限和中间件

### 租户ID获取
```go
// Go中间件自动注入
userInfo, _ := middleware.GetUserInfo(c)
tenantID := userInfo.BusinessID
```

### API验证
- `ValidityAPi` 中间件验证请求头
- `verify-encrypt`, `verify-time` headers

---

## 📚 参考资料

### Proto文件位置
- `andrew-protos/proto/recommender/v1/`

### 生成命令
```bash
cd andrew-protos
make generate
```

### 依赖更新
```bash
cd service_manager_server
go mod vendor  # 更新vendor
```

---

## ✅ 下一步工作

1. **实验结果展示** (待开发)
2. **数据集管理前端** (后端已完成)
3. **模型训练触发** (集成训练服务)
4. **实时推荐API** (在线服务)
5. **性能监控** (指标采集和展示)

---

**最后更新**: 2025-10-29  
**文档版本**: v1.0  
**维护者**: 开发团队

