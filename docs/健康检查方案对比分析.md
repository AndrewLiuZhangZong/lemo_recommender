# 健康检查方案对比分析

## 各服务特点与推荐方案

| 服务 | 服务类型 | 是否有端口 | 推荐方案 | 理由 |
|------|---------|-----------|---------|------|
| **HTTP API** | FastAPI Web | ✅ 10071 | **HTTP 探针** | 自带 `/health` 端点，标准做法 |
| **gRPC** | gRPC Server | ✅ 10072 | **gRPC Health Check** 或 **exec** | gRPC 标准健康检查协议 |
| **Celery Worker** | 后台任务执行 | ❌ 无端口 | **方案2: exec + Python 检查** | 简单可靠，避免额外开销 |
| **Celery Beat** | 定时调度器 | ❌ 无端口 | **方案2: exec + Python 检查** | 轻量级，检查 RedBeat 心跳 |
| **Kafka Consumer** | 消息消费者 | ❌ 无端口 | **方案2: exec + Python 检查** | 检查消费者状态，避免外部依赖 |

---

## 方案详解

### ✅ 方案1：HTTP 健康检查端点（适用于 HTTP/gRPC 服务）

**优点：**
- 业界标准
- K8s 原生支持
- 轻量高效

**缺点：**
- 需要服务本身支持 HTTP

**适用场景：**
- HTTP API ✅（已使用）
- gRPC（需额外实现）

---

### ✅ 方案2：exec 探针 + Python 脚本检查（适用于无端口服务）

**优点：**
- 不需要额外端口
- 可直接调用服务内部 API
- 避免引入新进程

**缺点：**
- exec 探针性能略低于 HTTP
- 需要容器内有必要的 Python 库

**适用场景：**
- Celery Worker ✅（推荐）
- Celery Beat ✅（推荐）
- Kafka Consumer ✅（推荐）

**实现示例：**

```yaml
livenessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      # Worker: 检查 Celery 状态
      from celery import Celery
      app = Celery('app.tasks.celery_app')
      app.control.inspect().ping()
  initialDelaySeconds: 30
  periodSeconds: 30
  timeoutSeconds: 10
```

---

### ⚠️ 方案3：添加独立健康检查 HTTP 服务（不推荐用于 Celery）

**优点：**
- 标准化
- 易于测试

**缺点：**
- 引入额外线程/进程
- 资源开销
- 复杂度增加

**结论：** 对于简单的后台服务，不值得

---

## 最终推荐

### 1️⃣ HTTP API 服务
**当前方案：** HTTP 探针 `/health` ✅

```yaml
livenessProbe:
  httpGet:
    path: /health
    port: 10071
  initialDelaySeconds: 30
  periodSeconds: 30
```

**保持不变** ✅

---

### 2️⃣ gRPC 服务
**当前方案：** exec 探针 ✅

```yaml
livenessProbe:
  exec:
    command:
    - python3
    - -c
    - "import grpc; channel = grpc.insecure_channel('localhost:10072'); channel.close()"
```

**建议优化：** 实现 gRPC Health Checking Protocol（可选）

---

### 3️⃣ Celery Worker
**推荐方案：** exec + Celery inspect

```yaml
livenessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      from celery import Celery
      from app.core.config import settings
      app = Celery(broker=settings.celery_broker_url)
      result = app.control.inspect().ping()
      if not result:
          exit(1)
  initialDelaySeconds: 60
  periodSeconds: 60
  timeoutSeconds: 15
  failureThreshold: 3

readinessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      from celery import Celery
      from app.core.config import settings
      app = Celery(broker=settings.celery_broker_url)
      result = app.control.inspect().active()
      # Worker 存在即可，不检查是否有任务
      exit(0)
  initialDelaySeconds: 30
  periodSeconds: 30
  timeoutSeconds: 10
```

---

### 4️⃣ Celery Beat
**推荐方案：** exec + RedBeat 状态检查

```yaml
livenessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      # 检查 RedBeat 调度器进程是否存在
      import psutil
      import sys
      for proc in psutil.process_iter(['name', 'cmdline']):
          cmdline = ' '.join(proc.info['cmdline'] or [])
          if 'celery' in cmdline and 'beat' in cmdline:
              sys.exit(0)
      sys.exit(1)
  initialDelaySeconds: 30
  periodSeconds: 60
  timeoutSeconds: 10
  failureThreshold: 3

readinessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      # Beat 进程存在即表示就绪
      import psutil
      import sys
      for proc in psutil.process_iter(['cmdline']):
          cmdline = ' '.join(proc.info['cmdline'] or [])
          if 'celery' in cmdline and 'beat' in cmdline:
              sys.exit(0)
      sys.exit(1)
  initialDelaySeconds: 20
  periodSeconds: 30
  timeoutSeconds: 5
```

---

### 5️⃣ Kafka Consumer
**推荐方案：** exec + 进程检查

```yaml
livenessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      import psutil
      import sys
      # 检查 Consumer 进程
      for proc in psutil.process_iter(['cmdline']):
          cmdline = ' '.join(proc.info['cmdline'] or [])
          if 'kafka_consumer' in cmdline or 'run_item_consumer' in cmdline:
              sys.exit(0)
      sys.exit(1)
  initialDelaySeconds: 30
  periodSeconds: 30
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  exec:
    command:
    - python3
    - -c
    - |
      # Consumer 进程存在即可
      import psutil
      import sys
      for proc in psutil.process_iter(['cmdline']):
          cmdline = ' '.join(proc.info['cmdline'] or [])
          if 'kafka_consumer' in cmdline or 'run_item_consumer' in cmdline:
              sys.exit(0)
      sys.exit(1)
  initialDelaySeconds: 20
  periodSeconds: 10
  timeoutSeconds: 5
```

---

## 总结

| 服务 | 方案 | 优势 | 实现成本 |
|------|------|------|---------|
| HTTP API | HTTP 探针 | ⭐⭐⭐⭐⭐ 标准、高效 | 已实现 |
| gRPC | exec 探针 | ⭐⭐⭐⭐ 简单可靠 | 已实现 |
| Worker | exec + Celery inspect | ⭐⭐⭐⭐ 准确检查 Worker 状态 | 低 |
| Beat | exec + psutil | ⭐⭐⭐⭐ 轻量进程检查 | 低 |
| Consumer | exec + psutil | ⭐⭐⭐⭐ 轻量进程检查 | 低 |

**核心原则：**
1. 有 HTTP 端口的用 HTTP 探针 ✅
2. 无端口的用 exec + Python 检查 ✅
3. 避免外部依赖（不检查 Redis/Kafka 连接）✅
4. 简单可靠优先于复杂标准 ✅

